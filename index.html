<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>J; Compiler</title>
  <style>
    body {
      font-family: monospace;
      background: #0f0f0f;
      color: #00ff9c;
      padding: 20px;
    }

    .editor-container {
      display: flex;
      border: 1px solid #00ff9c;
      background: #111;
    }

    .line-numbers {
      padding: 10px;
      text-align: right;
      user-select: none;
      color: #00ff9c;
      background: #0a0a0a;
      border-right: 1px solid #00ff9c;
      min-width: 30px;
    }

    #code {
      width: 100%;
      height: 220px;
      background: #111;
      color: #00ff9c;
      border: none;
      padding: 10px;
      resize: none;
      outline: none;
      white-space: pre;
    }

    button {
      margin-top: 10px;
      padding: 10px;
      background: #00ff9c;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }

    #screen {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #00ff9c;
      min-height: 100px;
    }

    details {
      margin-top: 20px;
      border: 1px solid #00ff9c;
      padding: 10px;
      background: #111;
    }

    summary {
      cursor: pointer;
      font-weight: bold;
      color: #00ff9c;
    }

    .doc-section-title {
      color: #00ff9c;
      font-weight: bold;
      margin-top: 10px;
    }
  </style>
</head>
<body>

<h1>J; Playground</h1>

<div class="editor-container">
  <div id="lineNumbers" class="line-numbers">1</div>
  <textarea id="code" oninput="updateLineNumbers()">
code.J;

make square-n-
    n * n
-

result = square 5
show screen "square(5) = " + result
  </textarea>
</div>

<button onclick="runJ()">Run J;</button>

<div id="screen"></div>

<details>
  <summary>Documentation</summary>

  <div class="doc-section-title">J; Language Documentation (Runtime-Synced)</div>
  <br><br>
  Version 0.2 — Syntax & runtime by Carter Hookey<br>
  <br>

  ------------------------------------------<br>
  1. File Header<br>
  ------------------------------------------<br>
  Every J; program must begin with:<br>
  code.J;<br>
  This tells the IDE or compiler that the file contains J; code.<br>
  <br>

  ------------------------------------------<br>
  2. Output Commands<br>
  ------------------------------------------<br>
  Show text or values on the screen:<br>
  show screen X<br>
  - If X is in quotes, it's printed as text: "hi"<br>
  - If X is a variable, its value is printed: result<br>
  - If X is an expression, it is evaluated: "answer: " + x*2<br>
  <br>
  Show text in the console:<br>
  show console X<br>
  (Same rules as show screen.)<br>
  <br>

  ------------------------------------------<br>
  3. Variables<br>
  ------------------------------------------<br>
  J; uses simple assignment with no variable keywords.<br>
  Create or update a variable:<br>
  x = value<br>
  - value can be a number, string ("hi"), or expression (1+2*3)<br>
  - Inside functions, variables are local to that function.<br>
  <br>

  ------------------------------------------<br>
  4. Blocks<br>
  ------------------------------------------<br>
  Blocks begin with - after the header line and end with a standalone -.<br>
  Example:<br>
  if x > 10-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;show screen "big"<br>
  -<br>
  This same block structure is used by:<br>
  - functions (make ... - ... -)<br>
  - loops (loop ... - ... -)<br>
  - if / else (if ... - ... -else- ... -)<br>
  <br>

  ------------------------------------------<br>
  5. Math and Expressions<br>
  ------------------------------------------<br>
  You can either use:<br>
  - Direct expressions in assignments and show commands:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;x = 1 + 2 * 3<br>
  &nbsp;&nbsp;&nbsp;&nbsp;show screen x * 2<br>
  <br>
  - Or the nE/e: prefix to compute and show:<br>
  nE/e: 8 * 9<br>
  (This evaluates the expression and prints the result.)<br>
  <br>

  ------------------------------------------<br>
  6. Functions<br>
  ------------------------------------------<br>
  Functions use no parentheses and use - to mark blocks.<br>
  <br>
  Function declaration:<br>
  make functionName-parameters-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -<br>
  <br>
  Example:<br>
  make greet-name-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;show screen "Hello " + name<br>
  -<br>
  <br>
  Multiple parameters (comma-separated):<br>
  make add-x, y-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;x + y<br>
  -<br>
  <br>
  Calling functions:<br>
  add 2, 3<br>
  greet "Carter"<br>
  <br>
  Anonymous functions are not yet implemented in this runtime.<br>
  (Planned: func-params- ... -)<br>
  <br>

  ------------------------------------------<br>
  7. Return values<br>
  ------------------------------------------<br>
  Explicit return:<br>
  return value<br>
  <br>
  Implicit return:<br>
  The last evaluated expression in the function body is returned automatically.<br>
  Example:<br>
  make square-n-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;n * n<br>
  -<br>
  <br>

  ------------------------------------------<br>
  8. Loops<br>
  ------------------------------------------<br>
  Loop a set number of times:<br>
  loop number-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -<br>
  Example:<br>
  loop 3-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;show screen "hi"<br>
  -<br>
  <br>
  Loop a random number of times (1 to 10):<br>
  loop random-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -<br>
  <br>
  Loop infinitely:<br>
  loop infinite-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -<br>
  (Warning: will run forever in this playground.)<br>
  <br>

  ------------------------------------------<br>
  9. Conditionals<br>
  ------------------------------------------<br>
  If statement:<br>
  if condition-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -<br>
  <br>
  If / else statement:<br>
  if condition-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -else-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;code<br>
  -<br>
  Example:<br>
  if x > 10-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;show screen "big"<br>
  -else-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;show screen "small"<br>
  -<br>
  <br>

  ------------------------------------------<br>
  10. Comments<br>
  ------------------------------------------<br>
  Write a comment using:<br>
  Comment: your comment here-<br>
  The whole line is ignored by the runtime.<br>
  <br>

  ------------------------------------------<br>
  11. Full Example Program<br>
  ------------------------------------------<br>
  code.J;<br>
  <br>
  make square-n-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;n * n<br>
  -<br>
  <br>
  make classify-x-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;if x > 10-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"big"<br>
  &nbsp;&nbsp;&nbsp;&nbsp;-else-<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"small"<br>
  &nbsp;&nbsp;&nbsp;&nbsp;-<br>
  -<br>
  <br>
  result = square 5<br>
  show screen "square(5) = " + result<br>
  show screen classify 12<br>

</details>

<script>
function updateLineNumbers() {
  const code = document.getElementById("code");
  const lineNumbers = document.getElementById("lineNumbers");

  const lines = code.value.split("\n").length;
  let numberText = "";

  for (let i = 1; i <= lines; i++) {
    numberText += i + "<br>";
  }

  lineNumbers.innerHTML = numberText;
}

// Run once on load
updateLineNumbers();

function runJ() {
  const inputLines = document.getElementById("code").value.split("\n");
  const screen = document.getElementById("screen");
  screen.innerHTML = "";

  let vars = {};          // global vars
  let functions = {};     // function defs
  let started = false;

  // Helper: print to screen
  function printToScreen(value) {
    screen.innerHTML += String(value) + "<br>";
  }

  // Helper: evaluate an expression with current vars
  function evalExpr(expr, localVars) {
    expr = expr.trim();
    if (expr === "") return null;

    // string literal
    if ((expr.startsWith('"') && expr.endsWith('"')) ||
        (expr.startsWith("'") && expr.endsWith("'"))) {
      return expr.slice(1, -1);
    }

    // If it's just a variable name
    if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(expr)) {
      if (expr in localVars) return localVars[expr];
      if (expr in vars) return vars[expr];
      return expr; // fallback: treat as plain text
    }

    // Replace variable names with scoped values
    const scope = Object.assign({}, vars, localVars);
    const names = Object.keys(scope);
    const values = Object.values(scope);

    try {
      // create a function with arguments as variable names
      const fn = new Function(...names, "return (" + expr + ");");
      return fn(...values);
    } catch (e) {
      return "❌ Expr error: " + expr;
    }
  }

  // Execute a block of J; code starting at index i
  // Returns { i: newIndex, lastValue }
  function executeBlock(lines, i, localVars) {
    let lastValue = null;
    while (i < lines.length) {
      let rawLine = lines[i];
      let line = rawLine.trim();
      i++;

      if (line === "" || line.startsWith("Comment:")) continue;

      // Block end
      if (line === "-") {
        return { i, lastValue };
      }

      // show screen
      if (line.startsWith("show screen")) {
        let expr = line.replace("show screen", "").trim();
        let value = evalExpr(expr, localVars || {});
        printToScreen(value);
        lastValue = value;
        continue;
      }

      // show console
      if (line.startsWith("show console")) {
        let expr = line.replace("show console", "").trim();
        let value = evalExpr(expr, localVars || {});
        console.log(value);
        lastValue = value;
        continue;
      }

      // Math expression via nE/e:
      if (line.startsWith("nE/e:")) {
        let expr = line.replace("nE/e:", "").trim();
        let value = evalExpr(expr, localVars || {});
        printToScreen(value);
        lastValue = value;
        continue;
      }

      // If statement / If-else
      if (line.startsWith("if ")) {
        let conditionExpr = line.slice(3).trim();
        let cond = evalExpr(conditionExpr, localVars || {});
        // collect the 'if' block
        let ifStart = i;
        let ifLines = [];
        let elseLines = null;
        let depth = 1;

        while (i < lines.length && depth > 0) {
          let l = lines[i].trim();

          if (l === "else-" && depth === 1) {
            elseLines = [];
            i++;
            // now collect else block until matching '-'
            while (i < lines.length) {
              let el = lines[i].trim();
              if (el === "-") {
                i++;
                depth = 0;
                break;
              }
              elseLines.push(lines[i]);
              i++;
            }
            break;
          }

          if (l === "-") {
            depth--;
            if (depth === 0) {
              i++;
              break;
            } else {
              ifLines.push(lines[i]);
            }
          } else {
            ifLines.push(lines[i]);
          }
          i++;
        }

        if (cond) {
          let res = executeBlock(ifLines, 0, localVars);
          lastValue = res.lastValue;
        } else if (elseLines) {
          let res = executeBlock(elseLines, 0, localVars);
          lastValue = res.lastValue;
        }
        continue;
      }

      // loop
      if (line.startsWith("loop ")) {
        let rest = line.slice(5).trim(); // e.g. "3-" or "random-" or "infinite-"
        if (!rest.endsWith("-")) {
          printToScreen("❌ Loop syntax error");
          continue;
        }
        let header = rest.slice(0, -1).trim();

        // collect block
        let blockLines = [];
        while (i < lines.length) {
          let l = lines[i].trim();
          if (l === "-") {
            i++;
            break;
          }
          blockLines.push(lines[i]);
          i++;
        }

        let count;
        if (header === "random") {
          count = Math.floor(Math.random() * 10) + 1; // 1–10
        } else if (header === "infinite") {
          // WARNING: infinite loop
          while (true) {
            let res = executeBlock(blockLines, 0, localVars);
            lastValue = res.lastValue;
          }
        } else {
          count = Number(evalExpr(header, localVars || {}));
          if (isNaN(count)) {
            printToScreen("❌ Loop count error");
            continue;
          }
        }

        for (let k = 0; k < count; k++) {
          let res = executeBlock(blockLines, 0, localVars);
          lastValue = res.lastValue;
        }
        continue;
      }

      // Function definition: make name-params-
      if (line.startsWith("make ")) {
        let header = line.slice(5).trim(); // name-params-
        if (!header.includes("-")) {
          printToScreen("❌ Function syntax error");
          continue;
        }

        let [namePart, paramsPart] = header.split("-", 2);
        let funcName = namePart.trim();
        let paramsRaw = paramsPart.trim().replace(/-$/, "");
        let params = [];
        if (paramsRaw.length > 0) {
          params = paramsRaw.split(",").map(p => p.trim());
        }

        // collect function body until closing '-'
        let bodyLines = [];
        while (i < lines.length) {
          let l = lines[i].trim();
          if (l === "-") {
            i++;
            break;
          }
          bodyLines.push(lines[i]);
          i++;
        }

        functions[funcName] = {
          params,
          bodyLines
        };
        continue;
      }

      // return inside a function block
      if (line.startsWith("return ")) {
        let expr = line.slice(7).trim();
        let value = evalExpr(expr, localVars || {});
        return { i, lastValue: value, returned: true };
      }

      // Variable assignment: x = expr
      if (line.includes("=")) {
        let parts = line.split("=");
        let name = parts[0].trim();
        let expr = parts.slice(1).join("=").trim();
        let value = evalExpr(expr, localVars || {});
        if (localVars) {
          localVars[name] = value;
        } else {
          vars[name] = value;
        }
        lastValue = value;
        continue;
      }

      // Function call: name args
      let callMatch = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s+(.*)$/);
      if (callMatch && functions[callMatch[1]]) {
        let funcName = callMatch[1];
        let argString = callMatch[2].trim();
        let fn = functions[funcName];
        let argValues = [];

        if (argString.length > 0) {
          // split by comma, but very naive
          let rawArgs = argString.split(",");
          for (let a of rawArgs) {
            argValues.push(evalExpr(a.trim(), localVars || {}));
          }
        }

        let newScope = {};
        fn.params.forEach((p, idx) => {
          newScope[p] = argValues[idx];
        });

        let res = executeBlock(fn.bodyLines, 0, newScope);
        // If there was an explicit return
        if (res && "returned" in res && res.returned) {
          lastValue = res.lastValue;
        } else {
          lastValue = res.lastValue;
        }
        continue;
      }

      // Standalone expression
      lastValue = evalExpr(line, localVars || {});
    }

    return { i, lastValue };
  }

  // MAIN INTERPRETATION LOOP
  let lines = inputLines;
  for (let idx = 0; idx < lines.length; ) {
    let rawLine = lines[idx];
    let line = rawLine.trim();

    if (line === "") {
      idx++;
      continue;
    }

    if (!started) {
      if (line === "code.J;") {
        started = true;
        idx++;
        continue;
      } else {
        screen.innerHTML = "❌ Missing code.J; header";
        return;
      }
    }

    // Once started, execute from here as a top-level block
    let res = executeBlock(lines, idx, null);
    break;
  }
}
</script>

</body>
</html>
